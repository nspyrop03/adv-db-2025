\section{Query 2}

Στόχος του δεύτερου ερωτήματος ήταν η επεξεργασία του συνόλου δεδομένων εγκληματικότητας (Crime Data) και του συνόλου δεδομένων "Race and Ethnicity codes" με στόχο την εξαγωγή δημογραφικών στατιστικών ανά έτος. Πιο συγκεκριμένα, το ζητούμενο ήταν ο εντοπισμός των τριών φυλετικών ομάδων (Victim Descent) με τον μεγαλύτερο αριθμό θυμάτων για κάθε έτος. Επιπλέον για κάθε ομάδα έπρεπε να υπολογιστεί το ποσοστό των θυμάτων επί του συνολικού αριθμού εγκλημάτων του συγκεκριμένου έτους. Η υλοποίηση του ερωτήματος ζητείται να γίνει με δύο τρόπου, DataFrame και SQL APIs, προκειμένου να συγκρίνουμε την απόδοση τους. 

\begin{table}[H]
	\centering
	\caption{Χρόνοι εκτέλεσης των δύο υλοποιήσεων του Query 2}
	\begin{tabular}{|c|c|}
		\hline
		Method & Time (s)\\
		\hline
		DF & 17.94\\
		SQL & 16.48\\
		\hline
	\end{tabular}
	\label{query2_table1}
\end{table}

Παρατηρώντας τα αποτελέσματα διαπιστώνουμε ότι οι χρόνοι έχουν αμελητέα διαφορά. Επιβεβαιώνεται λοιπόν η αρχιτεκτονική του Spark SQL Engine. Ανεξάρτητα από το αν η υλοποίηση του προβλήματος γίνεται με DataFrames ή SQL και οι δύο προσεγγίσεις περνούν από τον Catalyst Optimizer. Το SQL query αλλά και οι εντολές DataFrame μεταφράζονται στο ίδιο λογικό πλάνο και ο Catalyst Optimizer εφαρμόζει τις ίδιες βελτιστοποιήσεις. Επομένως η επιλογή μεταξύ DataFrame και SQL API δεν επηρεάζει την ταχύτητα της εκτέλεσης. 

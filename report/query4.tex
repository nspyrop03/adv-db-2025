\section{Query 4}

Για την υλοποιήση του τέταρτου ερωτήματος επιλέξαμε το DataFrame API. Όσον αφορά τους αστυνομικούς σταθμούς, χρησιμοποιούμε το dataset "LA Police Stations". Έτσι, χρειάστηκε να κάνουμε ένα cross join μεταξύ του πίνακα των εγκλημάτων και του πίνακα των σταθμών. Χρησιμοποιώντας την συνάρτηση \textit{"explain"}, βλέπουμε ότι το Spark χρησιμοποιεί τον αλγόριθμο \textbf{BroadcastNestedLoopJoin} για αυτή την ένωση στο Physical Plan του. Με αυτό τον αλγόριθμο, το μικρό dataset των σταθμών γίνεται broadcast σε όλους τους executors και στην συνέχεια με nested loops και όχι hash function γίνεται η ένωση. Θεωρούμε ότι αυτή η επιλογή είναι καλή καθώς ο μικρός πίνακας είναι ικανός να χωρέσει στην μνήμη του κάθε executor.

Στην συνέχεια, μας ζητείται από την εκφώνηση να τρέξουμε το query για 3 διαφρορετικά configurations ώστε να μελετήσουμε την κλιμάκωση του κώδικά μας. Σε κάθε configuration χρησιμοποιούμε 2 executors και παίρνουμε τους χρόνους που φαίνονται στον πίνακα \ref{query4_table}.

\begin{table}[H]
    \centering
    \caption{Χρόνοι εκτέλεσης των διαφορετικών configuration}
    \begin{tabular}{|c|c|}
        \hline
        Configuration & Time (s)\\
        \hline
        1 core,  2GB mem & 38.1\\
        2 cores, 4GB mem & 20.3\\
        4 cores, 8GB mem & 16.1\\
        \hline
    \end{tabular}
    \label{query4_table}
\end{table}

Παρατηρώντας τα αποτελέσματα του Πίνακα \ref{query4_table}, διαπιστώνουμε ότι η αύξηση των υπολογιστικών πόρων οδηγεί σε μείωση του χρόνου εκτέλεσης, με τον βαθμό βελτίωσης να ποικίλλει ανάλογα με το configuration:

\begin{enumerate}
    \item \textbf{Μετάβαση από Config 1 (1 core/2GB) σε Config 2 (2 cores/4GB)}: Παρατηρούμε σχεδόν γραμμική βελτιώση του χρόνου. Δίνοντας τους διπλάσιους πόρους το query μας εκτελείται περίπου στον μισό χρόνο. Αυτό δείχνει ότι το query, σε αυτό το στάδιο, είναι CPU-bound κάτι που περιμέναμε από την στιγμή που χρησιμοποιείται ένα nested loop join. Έτσι, με τους διπλάσιους πυρήνες, το Spark καταφέρνει να παραλληλοποιήσει αποτελεσματικά τον φόρτο εργασίας.
    \item \textbf{Μετάβαση από Config 2 (2 cores/4GB) σε Config 3 (4 cores/8GB)}: Σε αυτό το στάδιο, η αύξηση των πόρων δεν οδηγεί σε κάποια αξιόλογη επιτάχυνση. Παρόλο που διπλασιάσαμε ξανά τους πόρους, ο καινούριος χρόνος εκτέλεσης είναι λιγότερο από $4s$ μικρότερος. Για να εξηγήσουμε αυτό το φαινόμενο χρειάζεται να επικαλεστούμε τον νόμο του Amdahl, σύμφωνα με τον οποίο το μη παραλληλοποιήσιμο τμήμα της εργασίας θέτει ένα άνω όριο στη μέγιστη δυνατή επιτάχυνση - ένα όριο που φαίνεται να το φτάσαμε. Θεωρούμε ότι αυτό συμβαίνει καθώς, πλέον το query έχει μετατραπεί σε "I/O-bound" δηλαδή περιορίζεται από την ταχύτητα ανάγνωση του μεγάλου dataset και εγγραφής των αποτελεσμάτων από και προς τον δίσκο.
\end{enumerate}

Συμπερασματικά, η κλιμάκωση είναι αποδοτική μέχρι το Config 2 (2 cores/4GB), καθώς για το Config 3 βλέπουμε πως δεν υπάρχει ανάλογη επιτάχυνση και θα ήταν σπατάλη των περαιτέρω πόρων.
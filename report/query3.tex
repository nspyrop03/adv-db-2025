\section{Query 3}

Σε αυτό το ερώτημα πέρα από τα δύο μεγάλα datasets για τα εγκλήματα, χρησιμοποιούμε και το dataset "MO Codes" για την λεκτική περιγραφή κάθε κωδικού εγκλήματος. Επομένως, είναι αναγκαίο να ενώσουμε (join) τα δύο datasets μας για το σωστό σχηματισμό του query. Μπορούμε να δούμε ότι το dataset των εγκλημάτων είναι πολύ μεγαλύτερο από το dataset των κωδικών. Από την θεωρία γνωρίζουμε ότι για τέτοιες περιπτώσεις, ο αλγόριθμος Broadcast Hash Join είναι ο κατάλληλος. Πράγματι, χρησιμοποιώντας την συνάρτηση \textit{"explain"} στο τελικό dataframe object βλέπουμε ότι το Spark χρησιμοποιεί αυτόν τον αλγόριθμο χωρίς να του δώσουμε καμία εντολή ή παράμετρο επιπλεόν.

Αρχικά, μας ζητείται η σύγκριση δύο υλοποιήσεων - μία με DataFrame API και μία με RDD API. Όπως έχουμε ήδη αναφέρει, μόνο στην πρώτη θα αξιοποιηθεί ο Catalyst optimizer και αυτό φαίνεται και από τους χρόνους που λαμβάνουμε στον πίνακα \ref{query3_table1}. Η υλοποίηση με DataFrame είναι περίπου $4s$ πιο γρήγορη.

\begin{table}[H]
    \centering
    \caption{Χρόνοι εκτέλεσης των δύο πρώτων υλοποιήσεων του Query 3}
    \begin{tabular}{|c|c|}
        \hline
        Method & Time (s)\\
        \hline
        DF & 14.2\\
        RDD & 18.1\\
        \hline
    \end{tabular}
    \label{query3_table1}
\end{table}

Στην συνέχεια μας ζητείται να χρησιμοποιήσουμε την συνάρτηση \textit{"hint"} ώστε να ωθήσουμε το Spark να χρησιμοποιήσει διαφορετικούς αλγορίθμους για το join των δύο πινάκων. Έτσι, χρησιμοποιούμε την συνάρτηση καλώντας την από τον μικρό πίνακα και παίρνουμε τις μετρήσεις του πίνακα \ref{query3_table2}. Παρατηρούμε ότι οι χρόνοι εκτέλεσης μεταξύ των διαφορετικών στρατηγικών Join (SortMerge, ShuffleHash, Broadcast) παρουσιάζουν πολύ μικρές αποκλίσεις (εύρος περίπου $0.7s$). Αυτό το φαινομενικά παράδοξο αποτέλεσμα εξηγείται από τη φύση των δεδομένων μας.

Το dataset "MO Codes" είναι αρκετά μικρό σε μέγεθος. Ως αποτέλεσμα, το κόστος μεταφοράς του (network shuffle) ή ταξινόμησής του (sort) είναι αμελητέο συγκριτικά με τον χρόνο που απαιτείται για την ανάγνωση (I/O) και επεξεργασία του κύριου dataset των εγκλημάτων. Μπορούμε, λοιπόν, να θεωρήσουμε ότι το μεγαλύτερο χρονικό μέρος καταναλώνεται από το διάβασμα του μεγάλου πίνακα (CSV read operations) και όχι από τη διαδικασία του Join.

Στον πίνακα \ref{query3_table2} αναγράφεται "CartesianProduct" η ονομασία του join όταν δώσαμε στην συνάρτηση \textit{"hint"} την παράμετρο \textit{"SHUFFLE\_REPLICATE\_NL"}.

\begin{table}[H]
    \centering
    \caption{Χρόνοι εκτέλεσης των διαφορετικών join}
    \begin{tabular}{|c|c|}
        \hline
        Join & Time (s)\\
        \hline
        SortMergeJoin & 14.9\\
        ShuffleHashJoin & 14.5\\
        CartesianProduct & 14.3\\
        \hline
    \end{tabular}
    \label{query3_table2}
\end{table}